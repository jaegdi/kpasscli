
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>kpasscli: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">kpasscli/init.go (55.2%)</option>
				
				<option value="file1">kpasscli/main.go (83.0%)</option>
				
				<option value="file2">kpasscli/src/cmd/cli-params.go (97.0%)</option>
				
				<option value="file3">kpasscli/src/cmd/clipboard.go (40.7%)</option>
				
				<option value="file4">kpasscli/src/cmd/clipboard_unix.go (100.0%)</option>
				
				<option value="file5">kpasscli/src/config/config.go (85.7%)</option>
				
				<option value="file6">kpasscli/src/debug/debug.go (30.0%)</option>
				
				<option value="file7">kpasscli/src/doc/help.go (100.0%)</option>
				
				<option value="file8">kpasscli/src/doc/man.go (100.0%)</option>
				
				<option value="file9">kpasscli/src/keepass/keepass.go (53.7%)</option>
				
				<option value="file10">kpasscli/src/output/handler.go (83.6%)</option>
				
				<option value="file11">kpasscli/src/search/finder.go (86.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "fmt"
        "log"
        "os"
        "path/filepath"

        "kpasscli/src/cmd"
        "kpasscli/src/config"
        "kpasscli/src/debug"
        "kpasscli/src/doc"
        "kpasscli/src/search"
)

// var Flags *cmd.Flags

func Init() *cmd.Flags <span class="cov8" title="1">{
        log.SetFlags(log.LstdFlags)
        flags := cmd.ParseFlagsDefault()
        flag.Usage = doc.ShowHelp
        flag.Parse()

        // switch toggles
        if flags.DebugFlag </span><span class="cov8" title="1">{
                debug.Enable()
        }</span>
        <span class="cov8" title="1">if flags.VerifyFlag </span><span class="cov8" title="1">{
                search.EnableVerify()
        }</span>

        // Handle special flags and help messages
        <span class="cov8" title="1">if flags.CreateConfig </span><span class="cov0" title="0">{
                filename := "config.yaml"
                configPath := filepath.Join(".", filename)
                if err := config.CreateExampleConfig(configPath); err != nil </span><span class="cov0" title="0">{
                        debug.ErrMsg(err, "Error creating config file")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">debug.ErrMsg(nil, fmt.Sprintf("Example config file '%s' created successfully.", configPath))
                os.Exit(0)</span>
        }
        <span class="cov8" title="1">if flags.PrintConfig </span><span class="cov8" title="1">{
                cfg, err := config.Load(flags.ConfigPath)
                if err != nil </span><span class="cov0" title="0">{
                        debug.ErrMsg(err, "Error loading config")
                        os.Exit(1)
                }</span>
                <span class="cov8" title="1">cfg.Print()</span>
        }
        <span class="cov8" title="1">if flags.ShowMan </span><span class="cov0" title="0">{
                doc.ShowMan()
                os.Exit(0)
        }</span>
        <span class="cov8" title="1">if flags.ShowHelp </span><span class="cov0" title="0">{
                doc.ShowHelp()
                os.Exit(0)
        }</span>
        <span class="cov8" title="1">return flags</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/tobischo/gokeepasslib/v3"

        "kpasscli/src/cmd"
        "kpasscli/src/config"
        "kpasscli/src/debug"
        "kpasscli/src/keepass"
        "kpasscli/src/output"
        "kpasscli/src/search"
)

// RunApp contains the main application logic and is testable.
func RunApp(
        flags *cmd.Flags,
        loadConfig func(string) (*config.Config, error),
        resolveDBPath func(string, *config.Config) string,
        resolvePassword func(string, *config.Config, string, ...keepass.PasswordPromptFunc) (string, error),
        openDatabase func(string, string) (*gokeepasslib.Database, error),
        newFinder func(*gokeepasslib.Database) search.FinderInterface,
        newHandler func(output.OutputType) output.Handler,
        getEnv func(string) string,
) error <span class="cov8" title="1">{
        debug.Log("Starting kpasscli with item: %s", flags.Item)

        if flags.Item == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("item parameter is required")
        }</span>

        <span class="cov8" title="1">config, err := loadConfig(flags.ConfigPath)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Fprintf(os.Stderr, "Warning: Could not load config file: %v\n", err)
                if config == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
        // removed stray 'c'
        <span class="cov8" title="1">dbPath := resolveDBPath(flags.KdbPath, config)
        debug.Log("Resolved database path: %s", dbPath)
        if dbPath == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("no KeePass database path provided")
        }</span>

        <span class="cov8" title="1">kdbpasswordenv := getEnv("KPASSCLI_kdbpassword")
        password, err := resolvePassword(flags.KdbPassword, config, kdbpasswordenv)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Error getting password: %w", err)
        }</span>

        <span class="cov8" title="1">db, err := openDatabase(dbPath, password)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Error opening database: %w", err)
        }</span>

        <span class="cov8" title="1">finder := newFinder(db)
        // If the Finder supports Options, set them (for real Finder)
        if f, ok := finder.(*search.Finder); ok </span><span class="cov0" title="0">{
                f.Options = search.SearchOptions{
                        CaseSensitive: flags.CaseSensitive,
                        ExactMatch:    flags.ExactMatch,
                }
        }</span>
        <span class="cov8" title="1">results, err := finder.Find(flags.Item)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Error searching for item: %w", err)
        }</span>

        <span class="cov8" title="1">if len(results) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("no items found")
        }</span>

        <span class="cov8" title="1">if len(results) &gt; 1 </span><span class="cov8" title="1">{
                for _, result := range results </span><span class="cov8" title="1">{
                        fmt.Fprintf(os.Stderr, "- %s\n", result.Path)
                        debug.Log("Found item: %s", result.Path)
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("multiple items found")</span>
        }

        <span class="cov8" title="1">outputType := output.ResolveOutputType(flags.Out, config)
        handler := newHandler(outputType)

        value, err := results[0].GetField(flags.FieldName)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Error getting field: %w", err)
        }</span>

        <span class="cov8" title="1">if err := handler.Output(value); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Error outputting value: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func main() <span class="cov0" title="0">{
        flags := Init()
        err := RunApp(
                flags,
                config.Load,
                keepass.ResolveDatabasePath,
                func(passParam string, cfg *config.Config, kdbpassenv string, promptFunc ...keepass.PasswordPromptFunc) (string, error) </span><span class="cov0" title="0">{
                        return keepass.ResolvePassword(passParam, cfg, kdbpassenv, promptFunc...)
                }</span>,
                keepass.OpenDatabase,
                func(db *gokeepasslib.Database) search.FinderInterface <span class="cov0" title="0">{ return search.NewFinder(db) }</span>,
                output.NewHandler,
                os.Getenv,
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                debug.ErrMsg(err, "kpasscli")
                os.Exit(1)
        }</span>
}

// resolveOutputType remains unchanged
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "flag"

        "kpasscli/src/doc"
)

// parses command-line flags, and supports the following flags:
//
// -kdbpath | -p: Path to KeePass database file
// -kdbpassword | -w: Password file or executable to get password
// -item | -i: Item to search for
// -fieldname | -f: Field name to retrieve (default: "Password")
// -out | -o: Output type (clipboard/stdout)
// -case-sensitive | -c: Enable case-sensitive search
// -exact-match | -e: Enable exact match search
// -man | -m: Show manual page
// -help | -h: Show help message
// -debug | -d: Enable debug logging
// -config | -c path: Path to configuration file (default: ~/.config/kpasscli/config.yaml)
// -verify | -v: Enable verify messages
// -create-config | -cc: Create an example config file
// -print-config | -pc: print the current detected config to stdout

type Flags struct {
        KdbPath       string
        KdbPassword   string
        Item          string
        FieldName     string
        Out           string
        ConfigPath    string
        ClearAfter    int
        CaseSensitive bool
        ExactMatch    bool
        ShowMan       bool
        ShowHelp      bool
        DebugFlag     bool
        VerifyFlag    bool
        CreateConfig  bool
        PrintConfig   bool
        ShowAll       bool
}

// ParseFlags parses command-line flags from the provided FlagSet and arguments.
//
// Parameters:
//   - fs: The FlagSet to define and parse flags on.
//   - args: The arguments to parse (typically os.Args[1:]).
//
// Returns:
//   - *Flags: The parsed Flags struct with all options set.
//
// For production, use ParseFlagsDefault().
func ParseFlags(fs *flag.FlagSet, args []string) *Flags <span class="cov8" title="1">{
        flags := &amp;Flags{}
        fs.StringVar(&amp;flags.KdbPath, "kdbpath", "", "Path to KeePass database file")
        fs.StringVar(&amp;flags.KdbPath, "p", "", "Path to KeePass database file (shorthand)")

        fs.StringVar(&amp;flags.KdbPassword, "kdbpassword", "", "Password file or executable to get password")
        fs.StringVar(&amp;flags.KdbPassword, "w", "", "Password file or executable to get password (shorthand)")

        fs.StringVar(&amp;flags.Item, "item", "", "Item to search for")
        fs.StringVar(&amp;flags.Item, "i", "", "Item to search for (shorthand)")

        fs.StringVar(&amp;flags.FieldName, "fieldname", "Password", "Field name to retrieve")
        fs.StringVar(&amp;flags.FieldName, "f", "Password", "Field name to retrieve (shorthand)")

        fs.StringVar(&amp;flags.Out, "out", "", "Output type (clipboard/stdout)")
        fs.StringVar(&amp;flags.Out, "o", "", "Output type (clipboard/stdout) (shorthand)")

        fs.BoolVar(&amp;flags.CaseSensitive, "case-sensitive", false, "Enable case-sensitive search")
        fs.BoolVar(&amp;flags.CaseSensitive, "cs", false, "Enable case-sensitive search (shorthand)")

        fs.BoolVar(&amp;flags.ExactMatch, "exact-match", false, "Enable exact match search")
        fs.BoolVar(&amp;flags.ExactMatch, "e", false, "Enable exact match search (shorthand)")

        fs.BoolVar(&amp;flags.ShowMan, "man", false, "Show manual page")
        fs.BoolVar(&amp;flags.ShowMan, "m", false, "Show manual page (shorthand)")

        fs.BoolVar(&amp;flags.ShowHelp, "help", false, "Show help message")
        fs.BoolVar(&amp;flags.ShowHelp, "h", false, "Show help message (shorthand)")

        fs.BoolVar(&amp;flags.VerifyFlag, "verify", false, "Enable verify message")
        fs.BoolVar(&amp;flags.VerifyFlag, "v", false, "Enable verify message (shorthand)")

        fs.BoolVar(&amp;flags.DebugFlag, "debug", false, "Enable debug logging")
        fs.BoolVar(&amp;flags.DebugFlag, "d", false, "Enable debug logging (shorthand)")

        fs.BoolVar(&amp;flags.CreateConfig, "create-config", false, "Create an example config file")
        fs.BoolVar(&amp;flags.CreateConfig, "cc", false, "Create an example config file (shorthand)")

        fs.BoolVar(&amp;flags.PrintConfig, "print-config", false, "Print current configuration")
        fs.BoolVar(&amp;flags.PrintConfig, "pc", false, "Print current configuration (shorthand)")

        fs.StringVar(&amp;flags.ConfigPath, "config", "~/.config/kpasscli/config.yaml", "Path to configuration file")
        fs.StringVar(&amp;flags.ConfigPath, "c", "~/.config/kpasscli/config.yaml", "Path to configuration file (shorthand)")

        fs.Usage = doc.ShowHelp
        fs.Parse(args) // Parse the flags from the provided args. This is implemented to test the ParseFlags function.
        return flags
}</span>

// ParseFlagsDefault parses flags from the global flag.CommandLine and os.Args[1:].
//
// This is the default function to use in production. It sets up the flags, sets the usage function
// to show help documentation, and returns the parsed Flags struct. Typically called in main().
//
// Returns:
//   - *Flags: The parsed Flags struct with all options set.
func ParseFlagsDefault() *Flags <span class="cov0" title="0">{
        return ParseFlags(flag.CommandLine, nil)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "log"
        "os"
        "os/exec"
        "runtime" // Kann für performClipboardClear nützlich sein
        "strconv"

        // "syscall" // Wird hier nicht mehr direkt benötigt
        "time"

        "kpasscli/src/debug"
)

// runClearerDaemonMode ist die Funktion, die im separaten, losgelösten Prozess ausgeführt wird.
// Sie wartet die angegebene Anzahl von Sekunden und ruft dann performClipboardClear auf,
// um die Zwischenablage zu löschen. Danach beendet sie den Prozess.
// Parameter:
//   - delaySeconds: Die Anzahl der Sekunden, die gewartet werden soll, bevor die Zwischenablage gelöscht wird.
func runClearerDaemonMode(delaySeconds int) <span class="cov0" title="0">{
        if delaySeconds &lt;= 0 </span><span class="cov0" title="0">{
                os.Exit(1) // Sollte nicht passieren, aber sicher ist sicher
        }</span>

        // Warte die angegebene Zeit
        <span class="cov0" title="0">debug.Log("Clearer daemon started, waiting for %d seconds.", delaySeconds)
        time.Sleep(time.Duration(delaySeconds) * time.Second)

        // Führe die eigentliche Löschaktion aus
        debug.Log("Clearer daemon delay finished, attempting to clear clipboard.")
        performClipboardClear()

        debug.Log("Clearer daemon finished.")
        os.Exit(0)</span> // Erfolgreich beendet nach dem Löschen (oder Versuch)
}

// clearWaylandClipboard versucht, den Befehl zum Löschen der Zwischenablage unter Wayland zu finden und vorzubereiten.
// Es priorisiert 'wl-copy' und fällt auf 'xclip' oder 'xsel' zurück, falls 'wl-copy' nicht verfügbar ist.
// Rückgabewerte:
//   - clearCmdPath: Der Pfad zum gefundenen Befehl (oder leer, wenn keiner gefunden wurde).
//   - cmd: Ein vorbereitetes *exec.Cmd Objekt (kann nil sein, wenn pbcopy spezielle Behandlung braucht oder kein Befehl gefunden wurde).
func clearWaylandClipboard() (clearCmdPath string, cmd *exec.Cmd) <span class="cov8" title="1">{
        var err error
        var args []string
        clearCmdPath, err = exec.LookPath("wl-copy")
        if err == nil </span><span class="cov8" title="1">{
                args = []string{"-c"}
                debug.Log("Using wl-copy to clear Wayland clipboard")
        }</span> else<span class="cov0" title="0"> {
                debug.Log("wl-copy not found, trying xclip/xsel for Wayland (might not work)")
                clearCmdPath, err = exec.LookPath("xclip")
                if err == nil </span><span class="cov0" title="0">{
                        args = []string{"-selection", "clipboard", "-in", "/dev/null"}
                        debug.Log("Using xclip as fallback")
                }</span> else<span class="cov0" title="0"> {
                        clearCmdPath, err = exec.LookPath("xsel")
                        if err == nil </span><span class="cov0" title="0">{
                                args = []string{"-b", "-c"}
                                debug.Log("Using xsel as fallback")
                        }</span> else<span class="cov0" title="0"> {
                                // Kein geeignetes Kommando gefunden
                                clearCmdPath = "" // Sicherstellen, dass der Pfad leer ist
                        }</span>
                }
        }
        // Erstelle das Cmd-Objekt nur, wenn ein Pfad gefunden wurde
        <span class="cov8" title="1">if clearCmdPath != "" </span><span class="cov8" title="1">{
                cmd = exec.Command(clearCmdPath, args...)
        }</span>
        <span class="cov8" title="1">return clearCmdPath, cmd</span>
}

// clearX11Clipboard versucht, den Befehl zum Löschen der Zwischenablage unter X11 zu finden und vorzubereiten.
// Es priorisiert 'xclip' und fällt auf 'xsel' zurück, falls 'xclip' nicht verfügbar ist.
// Rückgabewerte:
//   - clearCmdPath: Der Pfad zum gefundenen Befehl (oder leer, wenn keiner gefunden wurde).
//   - cmd: Ein vorbereitetes *exec.Cmd Objekt (oder nil, wenn kein Befehl gefunden wurde).
func clearX11Clipboard() (clearCmdPath string, cmd *exec.Cmd) <span class="cov8" title="1">{
        var err error
        var args []string
        clearCmdPath, err = exec.LookPath("xclip")
        if err == nil </span><span class="cov8" title="1">{
                args = []string{"-selection", "clipboard", "-in", "/dev/null"}
                debug.Log("Using xclip to clear X11 clipboard")
        }</span> else<span class="cov0" title="0"> {
                clearCmdPath, err = exec.LookPath("xsel")
                if err == nil </span><span class="cov0" title="0">{
                        args = []string{"-b", "-c"}
                        debug.Log("Using xsel to clear X11 clipboard")
                }</span> else<span class="cov0" title="0"> {
                        // Kein geeignetes Kommando gefunden
                        clearCmdPath = "" // Sicherstellen, dass der Pfad leer ist
                        log.Printf("Warning: Could not find 'xclip' or 'xsel' to clear Linux X11 clipboard: %v", err)
                }</span>
        }
        // Erstelle das Cmd-Objekt nur, wenn ein Pfad gefunden wurde
        <span class="cov8" title="1">if clearCmdPath != "" </span><span class="cov8" title="1">{
                cmd = exec.Command(clearCmdPath, args...)
        }</span>
        <span class="cov8" title="1">return clearCmdPath, cmd</span>
}

// clearDarwinClipboard versucht, den Befehl 'pbcopy' zum Löschen der Zwischenablage unter macOS (Darwin) vorzubereiten.
// Das Löschen erfolgt, indem ein leerer Input an 'pbcopy' gesendet wird (EOF auf stdin).
// Rückgabewerte:
//   - clearCmdPath: Der Pfad zu 'pbcopy' (oder leer, wenn nicht gefunden).
//   - cmd: Ein vorbereitetes *exec.Cmd Objekt mit konfigurierter StdinPipe (oder nil, wenn 'pbcopy' nicht gefunden wurde).
func clearDarwinClipboard() (clearCmdPath string, cmd *exec.Cmd) <span class="cov0" title="0">{
        var err error
        clearCmdPath, err = exec.LookPath("pbcopy")
        if err == nil </span><span class="cov0" title="0">{
                cmd = exec.Command(clearCmdPath) // Keine Argumente nötig
                stdin, pipeErr := cmd.StdinPipe()
                if pipeErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Could not get stdin pipe for pbcopy: %v", pipeErr)
                        cmd = nil // Fehler beim Vorbereiten, kein Cmd zurückgeben
                        return
                }</span>
                // Sende sofort EOF, um die Zwischenablage zu leeren
                <span class="cov0" title="0">closeErr := stdin.Close()
                if closeErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Could not close stdin pipe for pbcopy: %v", closeErr)
                        // Fahren trotzdem fort, vielleicht funktioniert es dennoch
                }</span>
                <span class="cov0" title="0">debug.Log("Using pbcopy to clear macOS clipboard")</span>
        } else<span class="cov0" title="0"> {
                log.Printf("Warning: Could not find 'pbcopy' to clear macOS clipboard: %v", err)
                clearCmdPath = "" // Sicherstellen, dass der Pfad leer ist
                cmd = nil
        }</span>
        <span class="cov0" title="0">return clearCmdPath, cmd</span>
}

// clearWindowsClipboard bereitet den Befehl zum Löschen der Zwischenablage unter Windows vor.
// Verwendet 'cmd /c echo off | clip'.
// Rückgabewerte:
//   - clearCmdPath: Der Pfad zu 'cmd'.
//   - cmd: Ein vorbereitetes *exec.Cmd Objekt.
func clearWindowsClipboard() (clearCmdPath string, cmd *exec.Cmd) <span class="cov0" title="0">{
        clearCmdPath = "cmd"
        args := []string{"/c", "echo off | clip"}
        debug.Log("Using 'cmd /c echo off | clip' to clear Windows clipboard")
        cmd = exec.Command(clearCmdPath, args...) // Erstelle das Cmd-Objekt hier
        return clearCmdPath, cmd
}</span>

// performClipboardClear führt die eigentliche Aktion zum Löschen der Zwischenablage aus.
// Es erkennt das Betriebssystem, ruft die entsprechende Hilfsfunktion (clear*Clipboard) auf,
// um den Befehl zu erhalten, und führt diesen dann aus.
// Diese Funktion wird vom Hintergrundprozess (gestartet durch StartClipboardClearer) aufgerufen.
func performClipboardClear() <span class="cov8" title="1">{
        debug.Log("Attempting to clear clipboard.")

        var cmd *exec.Cmd
        var clearCmdPath string // Nur zur Information, ob ein Befehl gefunden wurde

        switch runtime.GOOS </span>{
        case "linux":<span class="cov8" title="1">
                if os.Getenv("WAYLAND_DISPLAY") != "" </span><span class="cov8" title="1">{
                        debug.Log("Detected Wayland display.")
                        clearCmdPath, cmd = clearWaylandClipboard()
                }</span> else<span class="cov0" title="0"> { // Annahme: X11
                        debug.Log("Assuming X11 display.")
                        clearCmdPath, cmd = clearX11Clipboard()
                }</span>
        case "darwin":<span class="cov0" title="0"> // macOS
                clearCmdPath, cmd = clearDarwinClipboard()</span>
        case "windows":<span class="cov0" title="0">
                clearCmdPath, cmd = clearWindowsClipboard()</span>
        default:<span class="cov0" title="0">
                log.Printf("Warning: Automatic clipboard clearing not supported on this OS: %s", runtime.GOOS)
                return</span>
        }

        // cmd sollte jetzt entweder ein gültiges *exec.Cmd sein oder nil, wenn kein Befehl gefunden/vorbereitet werden konnte.
        <span class="cov8" title="1">if cmd != nil </span><span class="cov8" title="1">{
                debug.Log("Executing clipboard clear command: %s %v", cmd.Path, cmd.Args)
                runErr := cmd.Run() // Führe den Befehl aus und warte auf das Ergebnis
                if runErr != nil </span><span class="cov0" title="0">{
                        // Bei pbcopy kann ein Fehler auftreten, wenn stdin geschlossen wird, was aber erwartet wird.
                        // Prüfe, ob es sich um pbcopy handelt und der Fehler spezifisch ist (optional, falls nötig).
                        // Fürs Erste loggen wir den Fehler immer.
                        log.Printf("Warning: Failed to clear clipboard: %v", runErr)
                }</span> else<span class="cov8" title="1"> {
                        debug.Log("Clipboard cleared successfully.")
                }</span>
        } else<span class="cov0" title="0"> if clearCmdPath == "" </span><span class="cov0" title="0">{ // Explizite Prüfung, ob überhaupt ein Pfad gefunden wurde
                // Diese Meldung wird bereits in den clear* funktionen geloggt, aber hier nochmal zur Sicherheit.
                log.Printf("Warning: No suitable command found or prepared to clear clipboard on %s.", runtime.GOOS)
        }</span> else<span class="cov0" title="0"> {
                // Fall, der eigentlich nicht eintreten sollte: Pfad gefunden, aber cmd ist nil (z.B. Fehler bei pbcopy pipe)
                log.Printf("Warning: Command path found (%s), but command execution object could not be prepared.", clearCmdPath)
        }</span>
}

// StartClipboardClearer startet einen *neuen*, vom Hauptprozess losgelösten (detached) Prozess,
// der nach einer bestimmten Verzögerung die Zwischenablage löscht.
// Der neue Prozess ist eine Instanz der aktuell laufenden kpasscli-Executable,
// die mit speziellen internen Flags aufgerufen wird.
// Parameter:
//   - delaySeconds: Die Anzahl der Sekunden, die der neue Prozess warten soll, bevor er die Zwischenablage löscht.
func StartClipboardClearer(delaySeconds int) <span class="cov8" title="1">{
        if delaySeconds &lt;= 0 </span><span class="cov0" title="0">{
                debug.Log("Clipboard clearing disabled (delay &lt;= 0).")
                return
        }</span>

        <span class="cov8" title="1">debug.Log("Attempting to start detached clipboard clearer process with delay: %d seconds", delaySeconds)

        // 1. Finde den Pfad zur aktuell laufenden kpasscli-Executable
        executablePath, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not find executable path to start clearer process: %v", err)
                return
        }</span>
        <span class="cov8" title="1">debug.Log("Executable path for clearer: %s", executablePath)

        // 2. Bereite die Argumente für den neuen Prozess vor
        args := []string{
                "--internal-clear-clipboard",                         // Das interne Flag, um runClearerDaemonMode auszulösen
                "--internal-clear-delay", strconv.Itoa(delaySeconds), // Das Delay übergeben
        }
        // Optional: Debug-Flag weitergeben, damit der Hintergrundprozess auch loggt
        if debug.Enabled() </span><span class="cov0" title="0">{
                args = append(args, "--debug") // oder "-d"
                debug.Log("Passing debug flag to clearer process.")
        }</span>
        <span class="cov8" title="1">debug.Log("Arguments for clearer process: %v", args)

        // 3. Erstelle das exec.Cmd Objekt
        cmd := exec.Command(executablePath, args...)

        // 4. WICHTIG: Prozess losgelöst starten (detached)
        //    Rufe die plattformspezifische Funktion auf, um SysProcAttr zu setzen.
        //    Dies stellt sicher, dass der neue Prozess weiterläuft, auch wenn der Hauptprozess endet.
        setDetachedProcessAttributes(cmd)
        debug.Log("Set detached process attributes.")

        // 5. Starte den Prozess
        err = cmd.Start() // Startet den Prozess und kehrt sofort zurück
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to start detached clearer process: %v", err)
                return
        }</span>

        // Der Prozess wurde erfolgreich gestartet. Der Hauptprozess kann nun normal beendet werden.
        // Der neue Prozess läuft im Hintergrund weiter.
        <span class="cov8" title="1">debug.Log("Detached clearer process started successfully (PID: %d). Main process will now exit.", cmd.Process.Pid)</span>

        // WICHTIG: Wir rufen cmd.Process.Release() NICHT auf, da der Prozess weiterlaufen soll.
        // Wir rufen cmd.Wait() NICHT auf, da wir nicht auf das Ende des Hintergrundprozesses warten wollen.
}
</pre>
		
		<pre class="file" id="file4" style="display: none">//go:build !windows

package cmd

import (
        "os/exec"
        "syscall"
)

// setDetachedProcessAttributes configures the command for detached execution on Unix-like systems.
//
// It sets the Setsid attribute to true, which starts the process in a new session,
// detaching it from the controlling terminal. This is commonly used for daemonizing
// processes on Unix/Linux.
//
// Parameters:
//   - cmd: The exec.Cmd object to configure for detached execution.
func setDetachedProcessAttributes(cmd *exec.Cmd) <span class="cov8" title="1">{
        if cmd.SysProcAttr == nil </span><span class="cov8" title="1">{
                cmd.SysProcAttr = &amp;syscall.SysProcAttr{}
        }</span>
        // Unter Linux/Unix: Prozess in einer neuen Sitzung starten, um ihn vom Terminal zu lösen
        <span class="cov8" title="1">cmd.SysProcAttr.Setsid = true</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"

        "gopkg.in/yaml.v2"

        "kpasscli/src/debug"
)

// Config represents the application configuration.
type Config struct {
        // DatabasePath is the default path to the KeePass database file
        DatabasePath string `yaml:"database_path"`
        // DefaultOutput specifies the default output type (stdout/clipboard)
        DefaultOutput      string `yaml:"default_output"`
        PasswordFile       string `yaml:"password_file"`
        PasswordExecutable string `yaml:"password_executable"`
        ConfigfilePath     string `yaml:"configfile_path"`
        OutputFormat       string `yaml:"output_format"`
}

// Load reads and parses the configuration file from the given path.
//
// Parameters:
//   - configPath: The path to the configuration file to load.
//
// Returns:
//   - *Config: The loaded configuration struct.
//   - error: Any error encountered during loading or parsing.
func Load(configPath string) (*Config, error) <span class="cov8" title="1">{
        if configPath == "" </span><span class="cov0" title="0">{
                configPath = filepath.Join(".", "config.yaml")
        }</span>
        <span class="cov8" title="1">if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                configPath = filepath.Join(os.Getenv("HOME"), ".config", "kpasscli", "config.yaml")
        }</span>
        <span class="cov8" title="1">debug.Log("Loading config from: %s\n", configPath)
        data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">debug.Log("Loaded data: %v\n", string(data))
        var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // config.ConfigfilePath = configPath
        <span class="cov8" title="1">y, _ := yaml.Marshal(config)
        debug.Log("Loaded config: %v\n", string(y))
        config.OutputFormat = "text"
        return &amp;config, nil</span>
}

// CreateExampleConfig creates an example configuration file at the specified path.
//
// Parameters:
//   - configPath: The path where the example config file should be created.
//
// Returns:
//   - error: Any error encountered during the creation of the config file.
func CreateExampleConfig(configPath string) error <span class="cov8" title="1">{
        exampleConfig := Config{
                DatabasePath:       "/path/to/your/database.kdbx",
                DefaultOutput:      "stdout",
                PasswordFile:       "/path/to/your/password.txt",
                PasswordExecutable: "[/path/to/your/]password_executable.sh",
        }
        data, err := yaml.Marshal(&amp;exampleConfig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return os.WriteFile(configPath, data, 0644)</span>
}

func (c *Config) Print() <span class="cov8" title="1">{
        fmt.Fprintf(os.Stderr, "Current used Configuration: %s\n", c.ConfigfilePath)
        fmt.Fprintf(os.Stderr, "------------------------------------------\n")
        fmt.Fprintf(os.Stderr, "Database Path: %s\n", c.DatabasePath)
        fmt.Fprintf(os.Stderr, "Default Output: %s\n", c.DefaultOutput)
        fmt.Fprintf(os.Stderr, "Password File: %s\n", c.PasswordFile)
        fmt.Fprintf(os.Stderr, "Password Executable: %s\n", c.PasswordExecutable)
        fmt.Fprintf(os.Stderr, "------------------------------------------\n")
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package debug

import (
        "fmt"
        "log"
        "os"
        "path/filepath"
        "regexp"
        "runtime"
        "strings"
)

var enabled bool

// Enabled returns true if debug logging is enabled.
//
// Returns:
//   - bool: True if debug logging is enabled, false otherwise.
func Enabled() bool <span class="cov0" title="0">{
        return enabled
}</span>

// Enable sets the debug logging flag to true.
//
// This function enables debug logging globally for the application.
func Enable() <span class="cov0" title="0">{
        enabled = true
}</span>

// ErrMsg prints an error message and exits the program if err is not nil.
//
// Parameters:
//   - err: The error to check.
//   - msg: The message to print if err is not nil.
//
// If err is not nil, this function prints the error and terminates the program with exit code 1.
func ErrMsg(err error, msg string) <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "ERROR %s: %v\n", msg, err)
                os.Exit(1)
        }</span>
}

// Log logs a debug message if debug logging is enabled.
//
// It includes the name of the calling function and the line number in the log message.
//
// Parameters:
//   - format: The format string for the log message, similar to fmt.Printf.
//   - v: The values to be formatted according to the format string.
func Log(format string, v ...interface{}) <span class="cov8" title="1">{
        for i := range v </span><span class="cov8" title="1">{
                val := v[i]
                valStr := fmt.Sprintf("%v", val)
                if matched, _ := regexp.MatchString(`(?i)password|passwort|-----BEGIN RSA PRIVATE KEY-----|-----BEGIN CERTIFICATE-----`, valStr); matched </span><span class="cov0" title="0">{
                        re := regexp.MustCompile(`(?is)(passwor(:?d|t)|-----BEGIN RSA PRIVATE KEY-----|-----BEGIN CERTIFICATE-----).*`)
                        v[i] = re.ReplaceAllString(valStr, "$1 ********")
                }</span>
        }
        <span class="cov8" title="1">if enabled </span><span class="cov0" title="0">{
                pc, file, line, ok := runtime.Caller(1)
                if ok </span><span class="cov0" title="0">{
                        fn := runtime.FuncForPC(pc)
                        funcName := fn.Name()
                        shortFuncName := funcName[strings.LastIndex(funcName, ".")+1:]
                        shortFile := filepath.Base(file)
                        log.Printf("%s:%d %s: "+format, append([]interface{}{shortFile, line, shortFuncName}, v...)...)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf(format, v...)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package doc

import (
        "fmt"
)

func ShowHelp() <span class="cov8" title="1">{
        help := `Usage: kpasscli [OPTIONS]

Options:
    -kdbpath | -p path      Path to KeePass database file
    -kdbpassword | -w path  Path to password file or executable, if not given asks for password interactively
    -config | -c            Path to config file
    -item | -i name         Entry to search for
    -all | -a               Show all entries of the specified item
    -fieldname | -f field   Field to retrieve (default: Password)
    -out | -o type          Output type (stdout/clipboard)
    -clear-after | -ca      Clear clipboard after N seconds ( default is 20sec, 0=disable, only active if output is clipboard)
    -case-sensitive | -cs   Enable case-sensitive search
    -exact-match | -e       Enable exact match search
    -config | -c path       Path to configuration file (default: ~/.config/kpasscli/config.yaml)
    -create-config | -cc    Create an example config file
    -print-config | -pc     Print the current detected config
    -verify | -v            Show the path of found item
    -debug | -d             Enable debug logging
    -man | -m               Show full manual
    -help | -h              Show this help

Example:
    kpasscli -kdbpath=/path/to/db.kdbx -kdbpassword=/path/to/pass.txt -item="/Personal/Banking/Account"
    kpasscli -p=/path/to/db.kdbx -w=/path/to/pass.txt -i="/Personal/Banking/Account"

    if keepass-db file and password-file|password-exec and output type is set in the config file
    then it's enough to specify the item and my be the fieldname.

    # for password
    kpasscli -i /Personal/Banking/Account

    # or if Account is uniq in the keepass-db
    kasscli -i Account

    # output passwort to clipboard an clear clipboard after 20 seconds
    kpasscli -i /Personal/Banking/Account -o clipboard -ca 20

    # To verify, if the right item was found, you can use the -verify flag
    kpasscli -i Account -v

    # for username
    kasscli -i /Personal/Banking/Account -f UserName

    # to show all entries of the specified item
    kasscli -i /Personal/Banking/Account -a

For more information, use -man | -m

AUTHOR
        Dirk Jäger

LICENSE
        GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007`

        fmt.Println(help)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package doc

import (
        "fmt"
)

const manPage = `NAME
    kpasscli - KeePass database command line interface

SYNOPSIS
    kpasscli [-kdbpath|-p path] [-kdbpassword|-w path] [-config|-c] -item|-i name [-fieldname|-f field] [-out|-o type] [-verify|-v] [-man|-m] [-help|-h]

DESCRIPTION
    kpasscli is a command-line tool for querying KeePass database files.
    It allows retrieving entries and their fields using various search methods.

    kpasscli is designed, to work in linux, Mac and Windows systems.

    The intention for this tool is to use it in automation scripts, to get secret strings like
    cert keys, key passwords, user or tech. user passwords, tokens, ..., which are stored in a keepass-db.
    And it supports optional to open the keepass-db without an interactive password prompt.

    If no -kdbpassword|-w is given, then kpasscli asks for the password to open the keepass-db interactively by a passwored prompt.

    If the item is found, it takes per default the value of the password field or if
    the parameter -fieldname|-f is given, the value of this field.

    Then it depends of the output config, if this is set to
    - stdout: The value is printed to stdout
    - clipboard: The value is copied into the clipboard and can be pasted wherever it is needed
      with tho parameter -ca nn  (or -clear-after nn)  the clipboard ist automatically cleared after nn seconds

OPTIONS
    -kdbpath|-p path
        Path to the KeePass database file. If not specified, the tool will look for
        the path in the KDBPATH environment variable or the config file.

    -kdbpassword|-w password-file
        Path to a file containing the database password or to an executable that
        outputs the password. For security reasons, the password cannot be provided
        directly on the command line.

    -config|-c config-file
        Path to a file containing the configuration settings. If not specified,
        the tool will look for the path in the KDBCONFIG environment variable
        or the default config file.

    -item|-i name
        The entry to search for. This can be:
        - An absolute path starting with "/" (e.g., "/Personal/Banking/Account")
        - A relative path (e.g., "Banking/Account")
        - A simple name (e.g., "Account")

    -fieldname|-f field
        The field to retrieve from the entry. Defaults to "Password".
        Common fields: Title, UserName, Password, URL, Notes

    -out|-o type
        How to output the retrieved value. Options:
        - stdout: Print to standard output (default)
        - clipboard: Copy to system clipboard

    -clear-after nn | -ca nn
        Clear clipboard after nn seconds (default is 20 sec., 0=disable, only active if output is clipboard)

    -case-sensitive|-cs
        Enable case-sensitive search

    -exact-match|-e
        Enable exact match search

    -config|-c path
        Path to the configuration file (default: ~/.config/kpasscli/config.yaml)
        
    -create-config|-cc
        Create an example configuration file

    -print-config|-pc
        Print the current detected config

    -man|-m
        Display this manual page

    -help|-h
        Display brief help message

    -verify|-v
        Show the path of found item

    -debug|-d
        Enable debug logging

SEARCH BEHAVIOR
    Absolute Path (/path/to/entry):
        Searches for an exact match at the specified location in the database.

    Relative Path (path/to/entry):
        Searches through all groups for a matching path.
        If multiple matches are found, lists all matches.

    Simple Name (entry):
        Searches all entries regardless of location.
        If multiple matches are found, lists all matches.

CONFIGURATION
    Configuration can be provided via a config.yaml file with the following fields:
    - database_path:       Default path to the KeePass database
    - default_output:      Default output type (stdout/clipboard)

    # Password retrieval methods, take care, this can be unsecure if you not protect the password file
    # or the executable properly. See SECURITY
    - password_file:       file which contains the password to open the keepass db
    - password_executable: the path to the executable, that returns the password to open the keepass database.
                           This method can be safe, if the executable itself asks for a general password to run it.

ENVIRONMENT
    KPASSCLI_KDBPATH       Alternative way to specify the KeePass database path
    KPASSCLI_OUT           Alternative way to specify the output type (stdout/clipboard)
    KPASSCLI_kdbpassword   Alternative way to specify the password file or executable

    define an alias like

        kpcl="kpasscli -ca 20 -o clipboard -i"
    
    in your shell-rc file.
    Then you can call 
    
        kpcl account  
    
    to get the password of account into the clipboard for 20 seconds. then the clipboard is cleared.

SECURITY
    To enable noninteractive access to open the keepass-db, there are two options:
    - provide a password-file
    - provide a executable that prints the password to STDOUT

    In both cases there are security risks, if this is not well prepared.

    A secure way is to use a wallet that is opened with the user login, like kwallet, if you use KDE Desktop.

EXAMPLES
    Get password for a specific entry:
        kpasscli -kdbpath=/path/to/db.kdbx -kdbpassword=/path/to/pass.txt -item="/Personal/Banking/Account"
        kpasscli -p=/path/to/db.kdbx -w=/path/to/pass.txt -i="/Personal/Banking/Account"

    Get username instead of password:
        kpasscli -kdbpath=/path/to/db.kdbx -kdbpassword=/path/to/pass.txt -item="Account" -fieldname=UserName
        kpasscli -p=/path/to/db.kdbx -w=/path/to/pass.txt -i="Account" -f=UserName

    Copy password to clipboard:
        kpasscli -kdbpath=/path/to/db.kdbx -kdbpassword=/path/to/pass.txt -item="Account" -out=clipboard
        kpasscli -p=/path/to/db.kdbx -w=/path/to/pass.txt -i="Account" -o=clipboard

SECURITY
    - Database passwords must be provided via file or executable
    - Clipboard contents are not automatically cleared
    - Be cautious when using clipboard output on shared systems

AUTHOR
    Dirk Jäger

LICENSE
          GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007
`

func ShowMan() <span class="cov8" title="1">{
        fmt.Print(manPage)
        fmt.Println()
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package keepass

import (
        "fmt"
        "os"
        "os/exec"
        "strings"
        "syscall"

        "github.com/tobischo/gokeepasslib/v3"
        "golang.org/x/term"

        "kpasscli/src/config"
        "kpasscli/src/debug"
        "kpasscli/src/output"
        "kpasscli/src/search"
)

// OpenDatabase opens and decodes a KeePass database file.
// Parameters:
//
//        path: Path to the KeePass database file
//        password: Password to decrypt the database
//
// Returns:
//
//        *gokeepasslib.Database: Decoded database object
//        error: Any error encountered during opening or decoding
func OpenDatabase(path string, password string) (*gokeepasslib.Database, error) <span class="cov8" title="1">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov8" title="1">{
                debug.Log("Error opening file: %v\n", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        debug.Log("OpenDatabase %s %s", path, strings.Repeat("*", len(password)))

        db := gokeepasslib.NewDatabase()
        db.Credentials = gokeepasslib.NewPasswordCredentials(password)
        // debug.Log("OpenDatabase\n%v\n", db)

        if err := gokeepasslib.NewDecoder(file).Decode(db); err != nil </span><span class="cov8" title="1">{
                debug.Log("Error decoding database: %v\n", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := db.UnlockProtectedEntries(); err != nil </span><span class="cov0" title="0">{
                debug.Log("Error unlocking protected entries: %v\n", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}

// PasswordPromptFunc defines a function type for prompting the user for a password.
type PasswordPromptFunc func() (string, error)

// ResolvePassword retrieves the database password from a file, executable, or prompt.
// The promptFunc parameter is optional; if nil, getPasswordFromPrompt is used.
// ResolvePassword retrieves the database password from a file or executable.
// It first checks if the password parameter is provided. If not, it falls back to the configuration.
// If the configuration specifies an executable, it runs the executable to get the password.
// If the password parameter is a named pipe, it reads the password from the pipe.
// If the password parameter is a regular file, it reads the password from the file.
// If the password parameter is an executable, it runs the executable to get the password.
// Parameters:
//   - passParam: The password parameter provided via command-line flag.
//   - cfg: The configuration object containing default paths and executables.
//   - kdbpassenv: The environment variable for the password, if set.
//   - promptFunc: Optional function to prompt for password if no file/executable is provided.
//
// Returns:
//   - string: The resolved password.
//   - error: Any error encountered during resolution.
func ResolvePassword(passParam string, cfg *config.Config, kdbpassenv string, promptFunc ...PasswordPromptFunc) (string, error) <span class="cov8" title="1">{

        passfile := ""
        if passParam != "" </span><span class="cov8" title="1">{
                passfile = passParam
        }</span> else<span class="cov8" title="1"> if kdbpassenv != "" </span><span class="cov8" title="1">{
                passfile = kdbpassenv
        }</span> else<span class="cov8" title="1"> if cfg.PasswordFile != "" </span><span class="cov8" title="1">{
                passfile = cfg.PasswordFile
        }</span> else<span class="cov8" title="1"> if cfg.PasswordExecutable != "" </span><span class="cov0" title="0">{
                passfile = cfg.PasswordExecutable
        }</span> else<span class="cov8" title="1"> {
                // Use injected promptFunc if provided, else default
                if len(promptFunc) &gt; 0 &amp;&amp; promptFunc[0] != nil </span><span class="cov8" title="1">{
                        return promptFunc[0]()
                }</span>
                <span class="cov0" title="0">return getPasswordFromPrompt()</span>
        }
        // Resolve environment variables in passfile
        // passfile = os.ExpandEnv(passfile)
        <span class="cov8" title="1">debug.Log("PassFile: %v", passfile)

        // Check if passfile is an executable in $PATH
        if execPath, err := exec.LookPath(passfile); err == nil </span><span class="cov8" title="1">{
                debug.Log("passfile: %v is an executable: %v", passfile, execPath)
                passfile = execPath
        }</span>
        <span class="cov8" title="1">info, err := os.Stat(passfile)
        if err != nil </span><span class="cov8" title="1">{
                debug.Log("passfile: %v Error: %v", passfile, err.Error())
                return "", fmt.Errorf("password must be provided via file or executable")
        }</span>
        <span class="cov8" title="1">debug.Log("%+v", info)

        if info.Mode()&amp;os.ModeNamedPipe != 0 </span><span class="cov0" title="0">{
                // Read password from process substitution
                data, err := os.ReadFile(passfile)
                if err != nil </span><span class="cov0" title="0">{
                        debug.Log(err.Error())
                        return "", err
                }</span>
                <span class="cov0" title="0">password := strings.TrimSpace(string(data))
                debug.Log("Resolved password from named pipe: %s", strings.Repeat("*", len(password)))
                return password, nil</span>
        }

        <span class="cov8" title="1">if info.Mode()&amp;0111 != 0 </span><span class="cov8" title="1">{
                // Execute file and read password from stdout
                cmd := exec.Command(passfile)
                output, err := cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        debug.Log(err.Error())
                        return "", err
                }</span>
                <span class="cov8" title="1">password := strings.TrimSpace(string(output))
                debug.Log("Resolved password from executable: %s", strings.Repeat("*", len(password)))
                return password, nil</span>
        }

        <span class="cov8" title="1">if info.Mode().IsRegular() </span><span class="cov8" title="1">{
                // Read password from file
                data, err := os.ReadFile(passfile)
                if err != nil </span><span class="cov0" title="0">{
                        debug.Log(err.Error())
                        return "", err
                }</span>
                <span class="cov8" title="1">password := strings.TrimSpace(string(data))
                debug.Log("Resolved password from file: %s", strings.Repeat("*", len(password)))
                return password, nil</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("password must be provided via file or executable")</span>
}

// getPasswordFromPrompt prompts the user to enter a password securely.
// It reads the password input without echoing it to the terminal, trims any
// leading or trailing whitespace, and returns the password as a string.
// If an error occurs while reading the password, it returns an empty string
// and the encountered error.
// Returns:
//   - string: The entered password, or an empty string if an error occurs.
//   - error: An error if one occurs while reading the password.
func getPasswordFromPrompt() (string, error) <span class="cov0" title="0">{
        // If no valid file or executable is found, prompt the user for the password
        fmt.Print("Enter password: ")
        var password string
        passwordBytes, err := term.ReadPassword(int(syscall.Stdin))
        if err != nil </span>{<span class="cov0" title="0">
        }</span>
        <span class="cov0" title="0">password = strings.TrimSpace(string(passwordBytes))
        fmt.Println()
        debug.Log("Resolved password from prompt: %s", strings.Repeat("*", len(password)))
        if password != "" </span><span class="cov0" title="0">{
                return password, nil
        }</span>
        <span class="cov0" title="0">return "", err</span>
}

// ResolveDatabasePath returns the KeePass database path based on flag, environment, or config.
//
// Parameters:
//   - flagPath: The path provided via command-line flag.
//   - cfg: The configuration object containing a default database path.
//
// Returns:
//   - string: The resolved database path, or empty string if not found.
func ResolveDatabasePath(flagPath string, cfg *config.Config) string <span class="cov8" title="1">{
        if flagPath != "" </span><span class="cov8" title="1">{
                return flagPath
        }</span>
        <span class="cov8" title="1">if envPath := os.Getenv("KPASSCLI_KDBPATH"); envPath != "" </span><span class="cov8" title="1">{
                return envPath
        }</span>
        <span class="cov8" title="1">if cfg != nil &amp;&amp; cfg.DatabasePath != "" </span><span class="cov8" title="1">{
                return cfg.DatabasePath
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// GetAllFields finds a specific entry by path and displays all its fields.
//
// Parameters:
//   - db: The KeePass database to search.
//   - config: The configuration object for output formatting.
//   - itemPath: The path of the entry to display.
//
// Returns:
//   - error: Any error encountered during the operation.
func GetAllFields(db *gokeepasslib.Database, config *config.Config, itemPath string) error <span class="cov0" title="0">{
        finder := search.NewFinder(db)
        // Rename the variable to 'results' to better reflect its type ([]search.Result)
        results, err := finder.Find(itemPath)
        if err != nil </span><span class="cov0" title="0">{
                // Wrap the error for better context
                return fmt.Errorf("error finding entry '%s': %w", itemPath, err)
        }</span>

        // Handle cases based on the number of results found
        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("entry not found: %s", itemPath)
        }</span>

        <span class="cov0" title="0">if len(results) &gt; 1 </span><span class="cov0" title="0">{
                // More than one entry found, which is ambiguous for showing all fields.
                // You might want to list the paths found instead.
                var foundPaths []string
                for _, res := range results </span><span class="cov0" title="0">{
                        foundPaths = append(foundPaths, res.Path)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("multiple entries found for '%s', please specify a unique path: %s", itemPath, strings.Join(foundPaths, ", "))</span>
        }

        // Exactly one result found. Access the Entry field from the first element.
        // The 'Entry' field within search.Result is the *gokeepasslib.Entry we need.
        <span class="cov0" title="0">singleEntry := results[0].Entry

        // It's good practice to check if the Entry pointer is nil, although Find should ideally populate it.
        if singleEntry == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("found result for '%s', but entry data is unexpectedly nil", itemPath)
        }</span>

        // Now pass the correct type (*gokeepasslib.Entry) to ShowAllFields
        <span class="cov0" title="0">output.ShowAllFields(singleEntry, *config)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package output

import (
        "encoding/json"
        "fmt"
        "os"
        "time"

        // Hinzugefügt für Debug-Logs

        "github.com/tobischo/gokeepasslib/v3"
        "golang.design/x/clipboard"

        "kpasscli/src/config"
        "kpasscli/src/debug"
)

type OutputChannel string

const (
        Clipboard  OutputChannel = "clipboard"
        Stdout     OutputChannel = "stdout"
        lineBreak                = "----------------------------------------"
        timeFormat               = "2006-01-02 15:04:05"
)

// Handler is an interface for outputting values.
type Handler interface {
        Output(string) error
}

// OutputType defines the type of output (clipboard or stdout)
type OutputType string

const (
        ClipboardType OutputType = "clipboard"
        StdoutType    OutputType = "stdout"
)

// stdHandler is the default implementation of Handler.
type stdHandler struct {
        outputType OutputType
}

// NewHandler creates a new Handler instance with the specified output type.
//
// Parameters:
//   - outputType: The OutputType specifying how output should be handled (clipboard or stdout).
//
// Returns:
//   - Handler: A new Handler instance for the specified output type.
func NewHandler(outputType OutputType) Handler <span class="cov8" title="1">{
        return &amp;stdHandler{outputType: outputType}
}</span>

// Output outputs the given value based on the handler's output type.
// Parameters:
//   - value: The value to be output.
//
// Returns:
//   - error: Any error encountered during output.
func (h *stdHandler) Output(value string) error <span class="cov8" title="1">{
        debug.Log("Outputting value: %s", value)
        switch h.outputType </span>{
        case ClipboardType:<span class="cov8" title="1">
                return h.toClipboard(value)</span>
        case StdoutType:<span class="cov8" title="1">
                return h.toStdout(value)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unknown output type: %s", h.outputType)</span>
        }
}

// toClipboard copies the given value to the system clipboard.
// Parameters:
//   - value: The value to be copied to the clipboard.
//
// Returns:
//   - error: Any error encountered during the clipboard operation.
func (h *stdHandler) toClipboard(value string) error <span class="cov8" title="1">{
        debug.Log("Copying to clipboard: %s", value)
        if err := clipboard.Init(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize clipboard: %v", err)
        }</span>
        <span class="cov8" title="1">clipboard.Write(clipboard.FmtText, []byte(value))
        return nil</span>
}

// toStdout prints the given value to the standard output.
// Parameters:
//   - value: The value to be printed to stdout.
//
// Returns:
//   - error: Any error encountered during the stdout operation.
func (h *stdHandler) toStdout(value string) error <span class="cov8" title="1">{
        debug.Log("Printing to stdout: %s", value)
        fmt.Println(value)
        return nil
}</span>

// IsValidType checks if the provided output type is valid.
//
// Parameters:
//   - outputType: The output type to check (string).
//
// Returns:
//   - bool: True if the output type is valid, false otherwise.
func IsValidType(outputType string) bool <span class="cov8" title="1">{
        switch OutputType(outputType) </span>{
        case ClipboardType, StdoutType:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// ShowAllFields displays all fields of a KeePass entry
// in a human-readable format.
// Parameters:
//   - entry: The KeePass entry to display.
//   - config: The configuration object containing output format settings.
//
// Returns:
//   - error: Any error encountered during the operation.
func ShowAllFields(entry *gokeepasslib.Entry, config config.Config) <span class="cov8" title="1">{
        if entry == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if config.OutputFormat == "json" </span><span class="cov8" title="1">{
                showAllFieldsJson(entry)
                return
        }</span>

        <span class="cov8" title="1">fmt.Println(lineBreak)
        fmt.Printf("Entry Details:\n")
        fmt.Println(lineBreak)

        // Standard fields
        printNonEmptyValue("Title", getValue(entry, "Title"))
        printNonEmptyValue("Username", getValue(entry, "UserName"))
        printNonEmptyValue("URL", getValue(entry, "URL"))
        printNonEmptyValue("Notes", getValue(entry, "Notes"))

        // Additional fields
        hasAdditionalFields := false
        for _, v := range entry.Values </span><span class="cov8" title="1">{
                if isAdditionalField(v.Key) &amp;&amp; v.Value.Content != "" </span><span class="cov8" title="1">{
                        if !hasAdditionalFields </span><span class="cov8" title="1">{
                                fmt.Println(lineBreak)
                                fmt.Println("Additional Fields:")
                                hasAdditionalFields = true
                        }</span>
                        <span class="cov8" title="1">printNonEmptyValue(v.Key, v.Value.Content)</span>
                }
        }

        // Metadata
        <span class="cov8" title="1">fmt.Println(lineBreak)
        fmt.Println("Metadata:")
        printNonEmptyValue("Created", formatTime(entry.Times.CreationTime.Time))
        printNonEmptyValue("Modified", formatTime(entry.Times.LastModificationTime.Time))
        printNonEmptyValue("Accessed", formatTime(entry.Times.LastAccessTime.Time))
        fmt.Println(lineBreak)</span>
}

// Helper functions
// getValue retrieves the value for a given key from the entry's values.
// Parameters:
//   - entry: The KeePass entry to search.
//   - key: The key for which to retrieve the value.
//
// Returns:
//   - string: The value associated with the key, or an empty string if not found
func getValue(entry *gokeepasslib.Entry, key string) string <span class="cov8" title="1">{
        for _, v := range entry.Values </span><span class="cov8" title="1">{
                if v.Key == key </span><span class="cov8" title="1">{
                        return v.Value.Content
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// printNonEmptyValue prints a key-value pair if the value is not empty.
// Parameters:
//   - key: The key to print.
//   - value: The value to print.
func printNonEmptyValue(key, value string) <span class="cov8" title="1">{
        if value != "" </span><span class="cov8" title="1">{
                fmt.Printf("%s: %s\n", key, value)
        }</span>
}

// formatTime formats a time.Time object into a string using the predefined time format.
// Parameters:
//   - t: The time.Time object to format.
//
// Returns:
//   - string: The formatted time string.
func formatTime(t time.Time) string <span class="cov8" title="1">{
        return t.Format(timeFormat)
}</span>

// isAdditionalField checks if a key is considered an additional field.
// Parameters:
//   - key: The key to check.
//
// Returns:
//   - bool: True if the key is an additional field, false otherwise.
func isAdditionalField(key string) bool <span class="cov8" title="1">{
        standardFields := map[string]bool{
                "Title":    true,
                "UserName": true,
                "URL":      true,
                "Notes":    true,
                "Password": true,
        }
        return !standardFields[key]
}</span>

// showAllFieldsJson outputs all fields of a KeePass entry in JSON format.
// Parameters:
//   - entry: The KeePass entry to display.
func showAllFieldsJson(entry *gokeepasslib.Entry) <span class="cov8" title="1">{
        type entryData struct {
                Title            string            `json:"title"`
                Username         string            `json:"username"`
                URL              string            `json:"url"`
                Notes            string            `json:"notes"`
                AdditionalFields map[string]string `json:"additional_fields,omitempty"`
                Metadata         struct {
                        Created  string `json:"created"`
                        Modified string `json:"modified"`
                        Accessed string `json:"accessed"`
                } `json:"metadata"`
        }

        data := entryData{
                Title:            getValue(entry, "Title"),
                Username:         getValue(entry, "UserName"),
                URL:              getValue(entry, "URL"),
                Notes:            getValue(entry, "Notes"),
                AdditionalFields: make(map[string]string),
        }

        // Fill additional fields
        for _, v := range entry.Values </span><span class="cov8" title="1">{
                if isAdditionalField(v.Key) &amp;&amp; v.Value.Content != "" </span><span class="cov8" title="1">{
                        data.AdditionalFields[v.Key] = v.Value.Content
                }</span>
        }

        // Fill metadata
        <span class="cov8" title="1">data.Metadata.Created = formatTime(entry.Times.CreationTime.Time)
        data.Metadata.Modified = formatTime(entry.Times.LastModificationTime.Time)
        data.Metadata.Accessed = formatTime(entry.Times.LastAccessTime.Time)

        jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error creating JSON output: %v\n", err)
                return
        }</span>

        <span class="cov8" title="1">fmt.Println(string(jsonData))</span>
}

// ResolveOutputType determines the output type based on the provided flag, environment variable, or configuration.
//
// Order of precedence:
//  1. If the flagOut parameter is not empty, it returns the corresponding output type.
//  2. If the environment variable "KPASSCLI_OUT" is set and valid, it returns the corresponding output type.
//  3. If the cfg parameter is not nil and cfg.DefaultOutput is not empty, it returns the corresponding output type.
//  4. If none of the above conditions are met, it defaults to output.StdoutType.
//
// Parameters:
//   - flagOut: A string representing the output type specified by a flag.
//   - cfg: A pointer to a config.Config struct that may contain a default output type.
//
// Returns:
//   - OutputType: The resolved output type based on the provided inputs.
func ResolveOutputType(flagOut string, cfg *config.Config) OutputType <span class="cov0" title="0">{
        if flagOut != "" </span><span class="cov0" title="0">{
                return OutputType(flagOut)
        }</span>
        <span class="cov0" title="0">if kpcliout := os.Getenv("KPASSCLI_OUT"); kpcliout != "" </span><span class="cov0" title="0">{
                if IsValidType(kpcliout) </span><span class="cov0" title="0">{
                        return OutputType(kpcliout)
                }</span>
        }
        <span class="cov0" title="0">if cfg != nil &amp;&amp; cfg.DefaultOutput != "" </span><span class="cov0" title="0">{
                return OutputType(cfg.DefaultOutput)
        }</span>
        <span class="cov0" title="0">return StdoutType</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package search

import (
        "fmt" // Hinzugefügt für Debug-Logs
        "os"
        "path/filepath"
        "strings"

        "github.com/tobischo/gokeepasslib/v3"

        "kpasscli/src/debug"
)

// FinderInterface abstracts the Find method for testability
// FinderInterface defines the interface for searching entries in a KeePass database.
// It provides a method to find entries based on a query string.
// This interface allows for different implementations of search logic, making it easier to test and extend functionality
type FinderInterface interface {
        Find(query string) ([]Result, error)
        // Optionally, add Options field if needed for tests
}

// Result represents the outcome of a search operation.
// It contains the path to the found entry and a pointer to the entry itself.
type Result struct {
        Path  string
        Entry *gokeepasslib.Entry
}

// GetField returns the value of the specified field from the entry
// GetField retrieves the value of a specified field from the entry.
// It searches through the entry's values and returns the content of the field if found.
// If the field is not found, it returns an error indicating that the field was not found.
// Parameters:
//   - fieldName: The name of the field to retrieve.
//
// Returns:
//   - The content of the field if found.
func (r *Result) GetField(fieldName string) (string, error) <span class="cov8" title="1">{
        for _, v := range r.Entry.Values </span><span class="cov8" title="1">{
                if strings.EqualFold(v.Key, fieldName) </span><span class="cov8" title="1">{
                        return v.Value.Content, nil
                }</span>
        }
        <span class="cov8" title="1">return "", fmt.Errorf("field '%s' not found", fieldName)</span>
}

var verify bool

// EnableVerify enables verification logging for search operations.
//
// This function sets the internal verify flag to true, enabling additional debug or verification output
// during search operations. Useful for debugging or testing.
func EnableVerify() <span class="cov8" title="1">{
        verify = true
}</span>

// SearchOptions defines the search behavior
type SearchOptions struct {
        CaseSensitive bool
        ExactMatch    bool
}

// Finder handles searching through the KeePass database
type Finder struct {
        db      *gokeepasslib.Database
        Options SearchOptions // Add Options field to Finder struct
}

// NewFinder creates a new Finder instance with default search options.
//
// Parameters:
//   - db: The KeePass database to search.
//
// Returns:
//   - *Finder: A new Finder instance ready for searching.
func NewFinder(db *gokeepasslib.Database) *Finder <span class="cov8" title="1">{
        return &amp;Finder{
                db:      db,
                Options: DefaultSearchOptions(),
        }
}</span>

// DefaultSearchOptions returns the default search options for Finder.
//
// Returns:
//   - SearchOptions: The default search options (case-insensitive, partial match).
func DefaultSearchOptions() SearchOptions <span class="cov8" title="1">{
        return SearchOptions{
                CaseSensitive: false, // Case-insensitive by default
                ExactMatch:    false, // Partial matching by default
        }
}</span>

// Find searches for entries in the KeePass database based on the provided query string.
//
// Parameters:
//   - query: Search query, can be absolute path, relative path, or entry name.
//
// Returns:
//   - []Result: Array of matching entries with their paths.
//   - error: Any error encountered during search.
func (f *Finder) Find(query string) ([]Result, error) <span class="cov8" title="1">{
        debug.Log("Starting search for query: %s", query) // Debug-Log hinzugefügt
        var results []Result

        if strings.HasPrefix(query, "/") </span><span class="cov8" title="1">{
                // Absolute path search
                entry, err := f.findByAbsolutePath(query)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("absolute path search failed: %w", err)
                }</span>
                <span class="cov8" title="1">if entry != nil </span><span class="cov8" title="1">{
                        results = append(results, Result{Path: query, Entry: entry})
                }</span>
        } else<span class="cov8" title="1"> if strings.Contains(query, "/") </span><span class="cov8" title="1">{
                // Subpath search
                var err error
                results, err = f.findBySubpath(query)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("subpath search failed: %w", err)
                }</span>
        } else<span class="cov8" title="1"> {
                // Name search
                var err error
                results, err = f.findByName(query)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("name search failed: %w", err)
                }</span>
        }
        // Wenn genau ein Eintrag gefunden wurde, gib den vollständigen Pfad aus
        <span class="cov8" title="1">if verify &amp;&amp; len(results) == 1 </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Found one entry: %s\n", results[0].Path)
        }</span>
        <span class="cov8" title="1">return results, nil</span>
}

// findByAbsolutePath finds an entry using an absolute path.
// It navigates through the groups in the database to locate the entry.
//
// Parameters:
//   - path: Absolute path starting with "/"
//
// Returns:
//   - *gokeepasslib.Entry: The found entry or nil
//   - error: Any error encountered during search
func (f *Finder) findByAbsolutePath(path string) (*gokeepasslib.Entry, error) <span class="cov8" title="1">{
        debug.Log("Searching by absolute path: %s", path) // Debug-Log hinzugefügt
        parts := strings.Split(strings.TrimPrefix(path, "/"), "/")
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty path")
        }</span>
        <span class="cov8" title="1">if parts[0] == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid path format")
        }</span>

        <span class="cov8" title="1">currentGroup := &amp;f.db.Content.Root.Groups[0]

        // Navigate through groups
        for i := 1; i &lt; len(parts)-1; i++ </span><span class="cov8" title="1">{ // i starts from 1 to include the root group
                found := false
                for _, group := range currentGroup.Groups </span><span class="cov8" title="1">{
                        if group.Name == parts[i] </span><span class="cov8" title="1">{
                                currentGroup = &amp;group
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("group not found: %s", parts[i])
                }</span>
        }

        // Search for entry in final group
        <span class="cov8" title="1">targetName := parts[len(parts)-1]
        for _, entry := range currentGroup.Entries </span><span class="cov8" title="1">{
                var title string
                for _, v := range entry.Values </span><span class="cov8" title="1">{
                        if v.Key == "Title" </span><span class="cov8" title="1">{
                                title = v.Value.Content
                                break</span>
                        }
                }
                <span class="cov8" title="1">if title == targetName </span><span class="cov8" title="1">{
                        return &amp;entry, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("entry not found: %s", targetName)</span>
}

// findBySubpath searches for entries matching a relative path pattern.
// The search is performed recursively through all groups in the database.
// It allows for partial matches within the specified path.
//
// Parameters:
//   - query: Relative path pattern (e.g., "Banking/Account")
//
// Returns:
//   - []Result: Array of matching entries with their full paths
//   - error: Any error encountered during search
func (f *Finder) findBySubpath(query string) ([]Result, error) <span class="cov8" title="1">{
        debug.Log("Searching by subpath: %s", query) // Debug-Log hinzugefügt
        parts := strings.Split(query, "/")
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid subpath query: must contain at least one '/'")
        }</span>

        <span class="cov8" title="1">var results []Result
        targetName := parts[len(parts)-1] // Last component is the entry name
        subPath := parts[:len(parts)-1]   // Other components form the path

        // Use finder options instead of default search options
        opts := f.Options
        // opts.ExactMatch = false // Exact match for subpath search

        debug.Log("Starting subpath search for query: %s", query)
        debug.Log("Subpath: %v, TargetName: %s", subPath, targetName)

        // Start recursive search from root group
        // currentPath := "/" + f.db.Content.Root.Groups[0].Name
        err := f.searchGroupForSubpath(&amp;f.db.Content.Root.Groups[0], "/", subPath, targetName, &amp;results, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("subpath search failed: %w", err)
        }</span>
        // Filter results by query string
        <span class="cov8" title="1">filteredResults := []Result{}
        for _, result := range results </span><span class="cov8" title="1">{
                if strings.Contains(result.Path, query) </span><span class="cov8" title="1">{
                        filteredResults = append(filteredResults, result)
                }</span>
        }
        <span class="cov8" title="1">results = filteredResults

        return results, nil</span>
}

// searchGroupForSubpath recursively searches through groups for matching paths.
// It checks if the current group matches the next path component and searches its entries.
// This function builds the full path for each group and checks if it matches the target name.
// It allows for partial matches within the specified path.
//
// Parameters:
//   - group: Current group being searched
//   - currentPath: Full path to current group
//   - searchPath: Remaining path components to match
//   - targetName: Name of the entry to find
//   - results: Slice to collect matching results
//   - opts: Search options controlling matching behavior
func (f *Finder) searchGroupForSubpath(
        group *gokeepasslib.Group,
        currentPath string,
        searchPath []string,
        targetName string,
        results *[]Result,
        opts SearchOptions,
) error <span class="cov8" title="1">{
        debug.Log("Searching group: %s, CurrentPath: %s, SearchPath: %v, TargetName: %s", group.Name, currentPath, searchPath, targetName)
        // Build the full path for the current group
        groupPath := currentPath
        if group.Name != "" </span><span class="cov8" title="1">{
                groupPath = filepath.Join(groupPath, group.Name)
        }</span>
        <span class="cov8" title="1">debug.Log("Updated groupPath: %s", groupPath)

        // If we're at the target depth (matched all path components)
        if len(searchPath) == 1 </span><span class="cov8" title="1">{
                debug.Log("At target depth, searching for entries in group: %s", group.Name)
                // Search for entries with matching name in this group
                for _, entry := range group.Entries </span><span class="cov8" title="1">{
                        var title string
                        for _, v := range entry.Values </span><span class="cov8" title="1">{
                                debug.Log("### v: %v", v)
                                if v.Key == "Title" </span><span class="cov8" title="1">{
                                        title = v.Value.Content
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">debug.Log("Checking entry: %s against target: %s", title, targetName)
                        // debug.Log("opts: %+v", opts)
                        if matchesName(title, targetName, opts) </span><span class="cov8" title="1">{
                                fullPath := filepath.Join(groupPath, title)
                                *results = append(*results, Result{
                                        Path:  "/" + fullPath, // Ensure path starts with /
                                        Entry: &amp;entry,
                                })
                                debug.Log("Found matching entry: %s", fullPath)
                        }</span> else<span class="cov0" title="0"> {
                                debug.Log("Entry %s does not match target %s", title, targetName)
                        }</span>
                }
        }

        // If there are more path components to match
        <span class="cov8" title="1">if len(searchPath) &gt; 0 </span><span class="cov8" title="1">{
                debug.Log("More path components to match, remaining searchPath: %v", searchPath)
                // Check if current group matches the next path component
                if matchesName(group.Name, searchPath[0], opts) </span><span class="cov8" title="1">{
                        debug.Log("Group name %s matches searchPath component %s", group.Name, searchPath[0])
                        // Recursively search subgroups with remaining path components
                        for i := range group.Groups </span><span class="cov0" title="0">{
                                err := f.searchGroupForSubpath(&amp;group.Groups[i], groupPath, searchPath[1:], targetName, results, opts)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        debug.Log("Group name %s does not match searchPath component %s", group.Name, searchPath[0])
                }</span>
        }

        // Always search all subgroups for potential matches
        // This allows finding matches even if intermediate path components don't match exactly
        <span class="cov8" title="1">debug.Log("Searching all subgroups for potential matches in group: %s", group.Name)
        for i := range group.Groups </span><span class="cov8" title="1">{
                err := f.searchGroupForSubpath(&amp;group.Groups[i], groupPath, searchPath, targetName, results, opts)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// matchesName checks if two strings match according to the search options
// matchesName checks if a given value matches a pattern based on the provided search options.
// It supports both case-sensitive and case-insensitive comparisons, as well as exact and partial matches.
//
// Parameters:
//   - value: The string to be searched.
//   - pattern: The string pattern to search for.
//   - opts: SearchOptions struct containing the following fields:
//   - CaseSensitive: A boolean indicating if the match should be case-sensitive.
//   - ExactMatch: A boolean indicating if the match should be exact.
//
// Returns:
//   - A boolean indicating whether the value matches the pattern based on the search options.
func matchesName(value, pattern string, opts SearchOptions) bool <span class="cov8" title="1">{
        // debug.Log("Matching value: %s against pattern: %s with options: %+v", value, pattern, opts)
        if opts.CaseSensitive </span><span class="cov8" title="1">{
                if opts.ExactMatch </span><span class="cov8" title="1">{
                        res := value == pattern
                        debug.Log("Case-sensitive exact match: %s against pattern: %s with options: %+v, result: %v", value, pattern, opts, res)
                        return res
                }</span>
                <span class="cov0" title="0">res := strings.Contains(value, pattern)
                debug.Log("Case-sensitive unexact match:%s against pattern: %s with options: %+v, result: %v", value, pattern, opts, res)
                return res</span>
        }

        // Case-insensitive comparison
        <span class="cov8" title="1">valueLower := strings.ToLower(value)
        patternLower := strings.ToLower(pattern)

        if opts.ExactMatch </span><span class="cov8" title="1">{
                res := value == pattern
                debug.Log("Exact match: %s against pattern: %s with options: %+v, result: %v", value, pattern, opts, res)
                return res
        }</span>
        <span class="cov8" title="1">res := strings.Contains(valueLower, patternLower)
        debug.Log("Unexact match: %s against pattern: %s with options: %+v, result: %v", value, pattern, opts, res)
        return res</span>
}

// findByName searches for entries by their name within the database.
// It performs an exact match search based on the provided query string.
//
// Parameters:
//   - query: The name to search for.
//
// Returns:
//   - A slice of Result containing the search results.
//   - An error if the search operation fails.
//
// Example usage:
//
//        results, err := finder.findByName("exampleName")
//        if err != nil {
//            log.Fatalf("Search failed: %v", err)
//        }
//        for _, result := range results {
//            fmt.Println(result)
//        }
func (f *Finder) findByName(query string) ([]Result, error) <span class="cov8" title="1">{
        debug.Log("Searching by name: %s", query) // Debug-Log hinzugefügt
        var results []Result
        opts := f.Options
        // opts.ExactMatch = false // Exact match for name search

        // Start recursive search from root group
        err := f.searchGroupForName(&amp;f.db.Content.Root.Groups[0], "", query, &amp;results, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("name search failed: %w", err)
        }</span>

        <span class="cov8" title="1">return results, nil</span>
}

// searchGroupForName searches for entries with a matching name within a given group and its subgroups.
// It appends the results to the provided results slice.
//
// Parameters:
//   - group - The group to search within.
//   - currentPath - The current path of the group being searched.
//   - targetName - The name to search for within the group's entries.
//   - results - A pointer to a slice where the search results will be appended.
//   - opts - Options for customizing the search behavior.
//
// Returns:
//   - An error if the search encounters an issue, otherwise nil.
func (f *Finder) searchGroupForName(
        group *gokeepasslib.Group,
        currentPath string,
        targetName string,
        results *[]Result,
        opts SearchOptions,
) error <span class="cov8" title="1">{
        debug.Log("Searching group: %s, CurrentPath: %s, TargetName: %s", group.Name, currentPath, targetName) // Debug-Log hinzugefügt
        // Build the full path for the current group
        groupPath := currentPath
        if group.Name != "" </span><span class="cov8" title="1">{
                if groupPath == "" </span><span class="cov8" title="1">{
                        groupPath = group.Name
                }</span> else<span class="cov8" title="1"> {
                        groupPath = filepath.Join(groupPath, group.Name)
                }</span>
        }

        // Search for entries with matching name in this group
        <span class="cov8" title="1">for _, entry := range group.Entries </span><span class="cov8" title="1">{
                var title string
                for _, v := range entry.Values </span><span class="cov8" title="1">{
                        if v.Key == "Title" </span><span class="cov8" title="1">{
                                title = v.Value.Content
                                break</span>
                        }
                }
                <span class="cov8" title="1">if matchesName(title, targetName, opts) </span><span class="cov8" title="1">{
                        fullPath := filepath.Join(groupPath, title)
                        *results = append(*results, Result{
                                Path:  "/" + fullPath, // Ensure path starts with /
                                Entry: &amp;entry,
                        })
                }</span>
        }

        // Recursively search subgroups
        <span class="cov8" title="1">for i := range group.Groups </span><span class="cov8" title="1">{
                err := f.searchGroupForName(&amp;group.Groups[i], groupPath, targetName, results, opts)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
